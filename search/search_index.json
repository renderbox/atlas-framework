{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Atlas App Framework","text":""},{"location":"#philosophy","title":"Philosophy","text":"<p>The Atlas App Framework was built out of over 15 years of Python experience developing apps for special use and across many different large scale Feature VFX and Animation Production pipelines, where the sheer amount of data is extremely high, integrations with 3rd parties is a constant and the end product needs to just be robust, but simply never fail.</p> <p>Out of this the need for a standard way for TDs and Engineers to develop dependable, ready for production apps very quickly</p> <p>The framework has a couple core elements to it's design:</p> <ul> <li>Pure Standard Python - The framework should be as free from external dependencies as possible. To meet this goal, the base of Atlas (for making CLI apps) has no external dependencies. The library only brings in what is needed (such as Pyside2 for GUIs) and the rest is up to you.</li> <li>The App Class is the Boilerplate - You should avoid re-writting boilerplate whenever possible. Boilerplate code should be kept as consistent &amp; stable as possible so it's DRY, robust and dependable.</li> <li>Stay Focused On Business Logic - Since Atlas takes care of the boilerplate, you are free to focus on the logic you need to implement.</li> <li>Apps are Classes - App classes themselves can be imported and used inside of other App classes or within other applications that support it (Maya, etc). This maximizes the code usage with DRY principles and lets you adapt the tool for the context it is written in.</li> <li>Mixins as Feature Plugins - If a highly reuseable feature is created (like adding a Pyside2 GUI), it should be added to your class using the mixin pattern. This extends what makes up the boilerplate foundation for your app with something that is thuroughly tested and ready for use.</li> </ul> <p>With that in mind, lets get to the next step, Getting Started.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If this is your fist time here, check out the Getting Started page to understand how to build something quickly with the Atlas App Framework.</p>"},{"location":"#pyside2-gui-app","title":"Pyside2 GUI App","text":"<p>Here is where you can extend your learning and create Pyside2 GUI based apps: PySide2 GUI Apps.</p>"},{"location":"#installed-app","title":"Installed App","text":"<p>Here is where you can find the docs on how to make your app installable: Installed Apps.</p>"},{"location":"#api","title":"API","text":"<p>If you are already familiar with the framework, here are the API docs to help you dive a little furhter in.</p>"},{"location":"#change-notes","title":"Change Notes","text":"<p>Change Notes are available here.</p>"},{"location":"#want-to-help","title":"Want to help?","text":"<p>I am always open to people interested in helping make this an even more capable and robust project. If you are interested in helping, just add a support ticket and we will connect.</p>"},{"location":"api/","title":"API Documentation","text":"<p>::: atlas.app.App handler: python</p>"},{"location":"change_notes/","title":"Change Notes","text":""},{"location":"change_notes/#v014","title":"v0.1.4","text":"<ul> <li>Setting Up Docs on GitHub Pages</li> <li>Tested GUI apps with PyInstaller to confirm Apps launch as expected and what's needed to make it work for developers</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This is a simple \"How To\" doc that takes you through the basics of setting up your application with the Atlas Framework.</p>"},{"location":"getting_started/#example","title":"Example","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>Before you can do anything, make sure you import the package into your environment:</p> <pre><code>&gt; pip install atlas\n</code></pre> <p>NOTE: It is highly reconmended to develop with a Python Virtual Environment when possible.</p>"},{"location":"getting_started/#the-sample-app","title":"The Sample App","text":"<p>You can run the sample app by copying the code below and putting it in a file called <code>sample_app.py</code>.</p> <pre><code>from atlas.app import App\n\n\nclass SampleApp(App):\n\n    description = \"This is a sample App\"\n\n    def add_arguments(self):\n        self.add_argument(\"-s\", \"--sample\", help=\"A sample CLI argument\")\n        self.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n\n    def run(self, ctx):\n        print(\"Hello All\")\n\n\ndef main():\n    \"\"\"This the function that instantiates the App Class and runs it.  This is to make it easy to create 'project.scripts'\n    in your pyproject.toml to run command from the command line.\n    \"\"\"\n    app = SampleApp()\n    app()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>You can run it just by calling it with the python interpreter.</p> <pre><code>&gt; python sample_app.py\n</code></pre> <p>If everything worked as expected you should see a message in the command prompt that says \"Hello All\".</p>"},{"location":"getting_started/#code-breakdown","title":"Code Breakdown","text":"<p>To help make this clear to understand let's break down what is going on. This first step is very common in Python code and imports the app class to inherit from. In this case it's the App class.</p> <pre><code>from atlas.app import App\n</code></pre> <p>Using the principle of code inheritence, the next thing we do is subclass the App class to make our own App. Every app using the Atlas Framework is based on the App class. It provides the core features and structure in which to write our apps. Other features (such as GUIs) are added as Mixin Classes (which we will get into later) but for now we will stick with the basic CLI foundation.</p> <pre><code>class SampleApp(App):\n    pass\n</code></pre> <p>If we just run this, we will get the default output (which is to print our execution context to the screen). This is good to show that it works but it's not a useful app yet. Let's try to give it something more to do.</p> <p>Right now our app does not have any command line arguments. These arguments allow us provide information to the application when we launch it. They can be input values or simply switches that change it's behavior to how we want it to work. In the example we replaced the <code>pass</code> placeholder with the following.</p> <pre><code>    def add_arguments(self):\n        self.add_argument(\"-s\", \"--sample\", help=\"A sample CLI argument\")\n        self.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n</code></pre> <p>By adding (technically overriding) the <code>add_arguments()</code> method we provide a method to add our own arguments to our app. The framework uses the same syntax as Python's ArgParse library so there is a lot of documentation on the format available. If you run the app again, you will now notice that the context output shows two more keys, \"sample\" and \"verbose\".</p> <p>If we want to see the help documentation for our app, we simply add the standard <code>-h</code> to the command when we run it.</p> <p>Atlas' goal is to try to keep you focused on the business logic so the next thing to do is add some business logic to our app by adding a <code>run()</code> method. This is where your app's unique business logic goes. In the example we just present you with a nice greeting.</p> <pre><code>    def run(self, ctx):\n        print(\"Hello All\")\n</code></pre> <p>That is pretty easy. Inside the run() method we have access to the context in which we are executing our code. The Context() object (ctx) is an extended dictionary that provides your app with a bunch of relevent information. It is a compilation of a configuation file, the environment, and command line arguments into a single context with each overriding the values in an order of importance. So values in a configuation file are overwritten by environment variables which are then overridden by command line arguments. If you want to access the different original data sources for any reason, they are all still available as part the context object as well.</p> <p>That's how we write an app. Now lets see a way to make it run.</p>"},{"location":"getting_started/#making-the-app-available-on-the-command-line","title":"Making the app available on the Command Line","text":"<p>The last two parts of te example show how you can launch your app.</p> <pre><code>if __name__ == \"__main__\":\n    main()\n</code></pre> <p>These lines at the end will run the function <code>main()</code> if it's in the first file the Python interpreter loads, aka the entry point.</p> <p>This works for demonstration purposes but it's not a very intuitive way to do things. It requires typing on the command line a long string that does not look like our app (<code>python test/sample.py -s \"bob\"</code> for example). We want something cleaner than that like <code>sample_app -s \"bob\"</code>.</p> <p>To make this available as a command line app we will leverage a convention used when packaging our project. In setup.py they are called \"entry_points\" and in <code>pyproject.toml</code> they are called 'project.scripts'. We follow the <code>pyproject.toml</code> aproach since, in addition to being more secure, it's the reconmended way from the PSF (Python Software Foundation).</p> <p>The first step is to create a function we can call.</p> <pre><code>def main():\n    \"\"\"This the function that instantiates the App Class and runs it.  This is to make it easy to create 'project.scripts' in your pyproject.toml to run command from the command line.\n    \"\"\"\n    app = SampleApp()\n    app()\n</code></pre> <p>We defined a function called <code>main()</code> that creates and instance of our App Class and then calls it. With the main() function defined we need to tell our package config about it and how to use it</p> <pre><code>[project.scripts]\nsample_app = \"test.sample:main\"\n</code></pre> <p>...and for setup.py (the older, deprecated way) it looks like this:</p> <pre><code>setup(\n    # ...,\n    entry_points={\n        'console_scripts': [\n            'sample_app = test.sample:main',\n        ]\n    }\n)\n</code></pre> <p>In both cases you will notice it's the name of the CLI app <code>sample_app</code> followed by <code>=</code> and then the import path to the module (<code>test.sample</code>), followed by a <code>:</code> and the method to call (<code>main</code>). The advantage of this aproach is when you install the package it will link the script to work on your command line shell, regardless of being on Linux, MacOS or Windows.</p> <p>Next Step -&gt; Pyside2 GUI App</p>"},{"location":"installed_app/","title":"Installed app","text":""},{"location":"installed_app/#making-an-installed-gui-app-with-pyinstaller","title":"Making an Installed GUI App with PyInstaller","text":"<p>BTW, if you are going to build a Pyside2 based GUI application using PyInstaller, make sure to include the \".ui\" file in the spec file. The first value in the tuple is the path to the .ui file and the second is where to put it as part of the install.</p> <pre><code>datas=[('SampleApp.ui','.')],\n</code></pre>"},{"location":"pyside2app/","title":"Pyside2app","text":""},{"location":"pyside2app/#creating-a-gui-app","title":"Creating a GUI App","text":"<p>Docs coming soon. Here is a teaser.</p> <pre><code>from atlas.app import App\nfrom atlas.app.gui import Pyside2Mixin\n\nclass SampleApp(Pyside2Mixin, App):\n    pass\n</code></pre> <p>Check out the test example in the repo under tests/sample_gui.py</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>atlas<ul> <li>app<ul> <li>base</li> <li>gui</li> </ul> </li> <li>context</li> </ul> </li> </ul>"},{"location":"reference/atlas/__init__/","title":"init","text":"<p>::: atlas</p>"},{"location":"reference/atlas/app/__init__/","title":"init","text":"<p>::: atlas.app</p>"},{"location":"reference/atlas/app/base/","title":"base","text":"<p>::: atlas.app.base</p>"},{"location":"reference/atlas/app/gui/","title":"gui","text":"<p>::: atlas.app.gui</p>"},{"location":"reference/atlas/context/__init__/","title":"context","text":"<p>::: atlas.context</p>"}]}